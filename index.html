<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sacrifices Must Be Made — Retro Open-World Prototype</title>
<style>
:root{
  --bg:#071018; --panel:#0f1720; --muted:#9aa4b2; --accent:#c94dff; --danger:#ff6b6b; --good:#6bffb8;
  font-family: "Press Start 2P", monospace, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}
html,body{height:100%; margin:0; background:linear-gradient(180deg,#03040a,#071018 70%); color:#e7eef8; -webkit-font-smoothing:antialiased;}
#ui {position:fixed; inset:8px; display:flex; justify-content:space-between; pointer-events:none; z-index:20}
.panel {pointer-events:auto; background:rgba(255,255,255,0.02); padding:8px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.03);}
.canvas-wrap{position:fixed; inset:0; display:flex; align-items:stretch; justify-content:center; padding:56px 24px; box-sizing:border-box;}
canvas{background:#071018; display:block; border-radius:8px; box-shadow:0 10px 40px rgba(0,0,0,0.6);}
.hud {position:fixed; left:16px; top:16px; pointer-events:none; color:#dbeafe; font-size:13px}
.hud .meter {display:inline-block; width:180px; height:10px; background:rgba(255,255,255,0.04); border-radius:6px; margin-right:8px; overflow:hidden}
.hud .meter > i{display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--accent),#ffb86b)}
.controls {position:fixed; right:16px; top:16px; pointer-events:auto; color:var(--muted); background:rgba(0,0,0,0.24); padding:8px; border-radius:8px}
.dialog {position:fixed; left:50%; bottom:36px; transform:translateX(-50%); width:78%; max-width:1100px; pointer-events:auto}
.dialog .box {background:linear-gradient(180deg,#071018,#0b1720); padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04); color:#e6f0ff}
.center {display:flex; gap:8px; align-items:center}
.end-screen{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.85)); z-index:50}
.end-card{background:#071018;border-radius:12px;padding:18px;border:1px solid rgba(255,255,255,0.04); color:#eaf3ff; width:820px; max-width:92vw}
.small{font-size:12px;color:var(--muted)}
kbd{background:#0b1220;border:1px solid rgba(255,255,255,0.04);padding:4px 6px;border-radius:6px;font-weight:700}
.pixel{image-rendering:pixelated}
</style>
</head>
<body>
<div id="ui">
  <div class="panel hud">
    <div style="font-weight:700">Influence <span id="txtInf">0</span></div>
    <div class="center" style="margin-top:6px">
      <div class="meter" id="infBar"><i></i></div>
      <div class="small" style="margin-left:6px">Guilt <span id="txtGuilt">0</span></div>
      <div class="meter" style="width:120px;margin-left:6px" id="guiltBar"><i style="background:linear-gradient(90deg,var(--danger),#ffb86b)"></i></div>
    </div>
  </div>

  <div class="panel controls">
    <div style="font-weight:700">Controls</div>
    <div class="small">← → Move • ↑ Jump/Climb • ↓ Interact</div>
    <div class="small">Z Punch • X Kick • C Sacrifice (prompt) • Enter advance</div>
    <div style="height:6px"></div>
    <div class="small">Objective: rise through the family. Sacrifices speed you — at a price.</div>
  </div>
</div>

<div class="canvas-wrap">
  <canvas id="game" width="1280" height="720"></canvas>
</div>

<div class="dialog" id="dialogRoot" style="display:none; z-index:15">
  <div class="box">
    <div id="dialogText" style="font-size:15px; line-height:1.4"></div>
    <div style="text-align:right; margin-top:8px"><button id="dialogNext" class="panel" style="pointer-events:auto">Next</button></div>
  </div>
</div>

<div class="end-screen" id="endScreen">
  <div class="end-card">
    <h2 id="endTitle">Ending</h2>
    <div id="endText" class="small" style="margin-top:8px"></div>
    <div style="text-align:right; margin-top:12px"><button id="restartBtn" class="panel" style="pointer-events:auto">Restart</button></div>
  </div>
</div>

<script>
/* -------------------------------------------------------------------------
   Sacrifices Must Be Made — Retro Open-World Platformer Prototype
   Single-file engine: tile map, player, NPC, dialog, sacrifice system,
   procedural sprites (pixel humans), and chiptune OST (procedural).
   ------------------------------------------------------------------------- */

/* -------------------------
   Init & Canvas
   ------------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
canvas.width = W * DPR; canvas.height = H * DPR;
ctx.setTransform(DPR,0,0,DPR,0,0);

/* DPI-safe helper */
function clear(){ ctx.fillStyle = '#071018'; ctx.fillRect(0,0,W,H); }

/* -------------------------
   Procedural pixel sprite generator
   returns an offscreen canvas with pixel art human
   style: humanistic retro (different palettes)
   ------------------------- */
function makeHumanSprite(palette, hat=false){
  const s = 32; // sprite size
  const oc = document.createElement('canvas');
  oc.width = s; oc.height = s;
  const octx = oc.getContext('2d');
  // simple block body
  octx.fillStyle = palette.skin; octx.fillRect(12,4,8,8); // head
  octx.fillStyle = palette.cloth; octx.fillRect(8,12,16,14); // body
  // eyes
  octx.fillStyle = palette.eye; octx.fillRect(14,6,2,2); octx.fillRect(18,6,2,2);
  // hair / hat
  octx.fillStyle = palette.hair; octx.fillRect(10,2,12,4);
  if(hat){ octx.fillStyle = palette.hat; octx.fillRect(8,0,16,4); }
  // legs
  octx.fillStyle = palette.pants; octx.fillRect(10,26,5,6); octx.fillRect(17,26,5,6);
  // small shading
  octx.globalAlpha = 0.08; octx.fillStyle = '#000'; octx.fillRect(8,12,16,4);
  octx.globalAlpha = 1;
  // scale up to crisp pixels when drawn (we use image-smoothing off)
  return oc;
}

/* palettes */
const palettes = {
  player: { skin:'#ffd6a5', cloth:'#6b4e3d', hair:'#2b1c10', pants:'#182030', eye:'#041018', hat:'#522244' },
  mom: { skin:'#ffddb3', cloth:'#8fb5ff', hair:'#663122', pants:'#3c2e2e', eye:'#041018', hat:'#aa4444' },
  thug: { skin:'#f4d3b4', cloth:'#6b6b6b', hair:'#111', pants:'#222', eye:'#041018', hat:'#222' }
};

const SPRITES = {
  player: makeHumanSprite(palettes.player, false),
  mom: makeHumanSprite(palettes.mom, false),
  thug: makeHumanSprite(palettes.thug, true)
};

/* -------------------------
   Small procedural chiptune OST + SFX
   ------------------------- */
class AudioSys {
  constructor(){
    this.ctx = null;
    this.master = null;
    this.started = false;
  }
  ensure(){
    if(this.ctx) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.master = this.ctx.createGain(); this.master.gain.value = 0.18; this.master.connect(this.ctx.destination);
    // create a gentle loop
    this.bpm = 80;
    this.scheduleLoop();
  }
  start(){ this.ensure(); this.started = true; }
  scheduleLoop(){
    // simple repeating pluck + bass drone
    const ctx = this.ctx;
    if(!ctx) return;
    // drone oscillator
    const drone = ctx.createOscillator(); drone.type='sine'; drone.frequency.value = 55;
    const g = ctx.createGain(); g.gain.value = 0.02;
    drone.connect(g); g.connect(this.master);
    drone.start();
    // light pluck scheduled periodically
    setInterval(()=> {
      const o = ctx.createOscillator(); o.type='triangle'; o.frequency.value = 220 + Math.random()*60;
      const gg = ctx.createGain(); gg.gain.value = 0.0001; o.connect(gg); gg.connect(this.master);
      const t = ctx.currentTime;
      gg.gain.linearRampToValueAtTime(0.06, t+0.02);
      gg.gain.exponentialRampToValueAtTime(0.001, t+0.6);
      o.start(t); o.stop(t+0.8);
    }, 1000);
  }
  sfxBeep(freq=880, time=0.06){ this.ensure(); const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=0.0001; o.connect(g); g.connect(this.master); const t=this.ctx.currentTime; g.gain.linearRampToValueAtTime(0.06,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+time); o.start(t); o.stop(t+time+0.02); }
  sfxBuzz(time=0.06){ this.sfxBeep(120,time); }
}
const AUDIO = new AudioSys();

/* -------------------------
   Basic tile map & world generator
   We'll make a few connected districts (alley, rooftop, club interior)
   Tile size = 32
   ------------------------- */
const TILE = 32;
function createWorld(){
  // simple map: array of "screens" horizontally connected
  // Each screen has width 40 tiles (~1280 px), height 20 tiles (640)
  const screens = [];
  // helper to create empty screen with ground
  function emptyScreen(type='alley'){
    const w = 40, h = 20;
    const map = Array.from({length:h}, ()=>Array(w).fill(0));
    // ground row
    for(let x=0;x<w;x++) map[h-3][x]=1; // ground tile
    // some platforms
    if(type==='alley'){
      for(let i=6;i<30;i+=8) { map[h-6][i]=1; map[h-9][i+3]=1; }
    } else if(type==='rooftop'){
      for(let i=4;i<w-4;i+=10) { map[h-6][i]=1; map[h-7][i+1]=1; }
      // chimneys / obstacles
      for(let c=10;c<w-6;c+=12) map[h-8][c]=2;
    } else if(type==='club'){
      // darker interior: more obstacles
      for(let p=8;p<w-6;p+=6) map[h-7][p]=1;
    }
    return map;
  }
  screens.push({type:'alley', map: emptyScreen('alley')});
  screens.push({type:'club', map: emptyScreen('club')});
  screens.push({type:'rooftop', map: emptyScreen('rooftop')});
  return screens;
}
let worldScreens = createWorld();

/* world camera */
let cam = {x:0, y:0, w:W, h:H};

/* -------------------------
   Entities: player, NPCs
   ------------------------- */
function makePlayer(){
  return {
    x: 200, y: 440, w:28, h:36, vx:0, vy:0, onGround:false,
    dir:1, health:100, punchTimer:0, kickTimer:0, state:'idle',
    inventory:{}, rank:0
  };
}
let player = makePlayer();

/* simple NPC */
function makeNPC(x,y,kind='thug'){
  return {
    x,y,w:28,h:36, kind, state:'idle', dir:1, vx:0, patrol:[x-80,x+80], timer:0, alive:true
  };
}

/* NPC list */
let npcs = [
  makeNPC(600, 440, 'thug'),
  makeNPC(980, 440, 'thug'),
  {x:1400, y: 420, w:28, h:36, kind:'mom', state:'idle', dialogId:'mom_intro', alive:true}
];

/* current screen index (which world screen the camera is focused on) */
let screenIndex = 0;

/* -------------------------
   Input
   ------------------------- */
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key==='Escape'){ paused = !paused; } if(e.key==='Enter'){ advanceDialog(); }});
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

/* -------------------------
   Game state: influence, guilt, rank, story
   ------------------------- */
let influence = 0; let guilt = 0; let rank = 0;
let paused=false;
let dialogQueue = []; let dialogActive=false;
const dialogRoot = document.getElementById('dialogRoot');
const dialogText = document.getElementById('dialogText');
const dialogNext = document.getElementById('dialogNext');

dialogNext.addEventListener('click', ()=> advanceDialog());

function queueDialog(lines, onComplete=null){
  dialogQueue.push({lines: Array.isArray(lines)?lines:[lines], idx:0, onComplete});
  if(!dialogActive) showNextDialog();
}
function showNextDialog(){
  if(dialogQueue.length===0){ dialogActive=false; dialogRoot.style.display='none'; return; }
  dialogActive=true; dialogRoot.style.display='block';
  const dlg = dialogQueue[0];
  dialogText.innerHTML = dlg.lines[dlg.idx];
}
function advanceDialog(){
  if(!dialogActive) return;
  const dlg = dialogQueue[0];
  dlg.idx++;
  if(dlg.idx >= dlg.lines.length){ // finished
    const cb = dlg.onComplete;
    dialogQueue.shift();
    dialogRoot.style.display = 'none';
    dialogActive = false;
    if(cb) cb();
    // next if queued
    if(dialogQueue.length>0) showNextDialog();
  } else {
    showNextDialog();
  }
}

/* -------------------------
   Dialogue and story nodes
   ------------------------- */
const story = {
  start: ()=> {
    queueDialog([
      "<b>Brooklyn, 1983</b><br>You live with your mother in a cramped apartment above a deli. Life is thin. The family offers you a way up — but every favor has a price.",
      "Walk to the alley and find the crew's lieutenant to prove yourself."
    ], ()=>{ /* on complete */});
  },
  mom_intro: ()=> {
    queueDialog([
      "Mom: \"You gotta be careful out there, baby. Promise me you'll stay out of trouble.\"",
      "You feel the weight of the choice. To climb you might have to... give something up."
    ], ()=> {
      // present choice to sacrifice mom
      presentSacrificeChoice();
    });
  },
  afterSacrifice: (sacrificed)=> {
    if(sacrificed){
      queueDialog([
        "You made the choice. The world bends. Influence rises; your reflection looks stranger.",
        "You walk away from the alley with a new name on your lips."
      ], ()=>{ /* continue game state change handled elsewhere */});
    } else {
      queueDialog([
        "You refuse. Your heart aches but some things remain yours. The family respects strength — but also results.",
        "You continue, slower but with some light in your chest."
      ]);
    }
  }
};

/* -------------------------
   Sacrifice mechanic (major story choice)
   ------------------------- */
function presentSacrificeChoice(){
  // show custom dialog UI with two big choices; simplified via queue
  // we'll pause gameplay and show two "buttons" by using dialog and hotkeys: Y to sacrifice, N to refuse
  paused = true;
  queueDialog([
    "<b>Sacrifice?</b><br>Give up something dear to gain immediate influence. Sacrifices raise your Guilt permanently.",
    "Press <kbd>Y</kbd> to sacrifice your mother (gain Influence but lose a moral anchor), or <kbd>N</kbd> to refuse."
  ]);
  // temporary key handlers
  function onKey(e){
    if(e.key.toLowerCase() === 'y'){
      window.removeEventListener('keydown', onKey);
      performSacrifice('mom');
    } else if(e.key.toLowerCase() === 'n'){
      window.removeEventListener('keydown', onKey);
      performSacrifice(null);
    }
  }
  window.addEventListener('keydown', onKey);
}

function performSacrifice(target){
  // handle effects
  if(target === 'mom'){
    // simulate strong consequence: remove mom npc, big influence gain, large guilt increase
    npcs = npcs.filter(n => !(n.kind === 'mom'));
    influence += 120;
    guilt += 55;
    rank += 1;
    AUDIO.sfxBeep(1000,0.12);
    story.afterSacrifice(true);
  } else {
    // refused
    influence += 8;
    guilt += 6;
    AUDIO.sfxBeep(440,0.08);
    story.afterSacrifice(false);
  }
  paused = false;
  updateStatsUI();
}

/* -------------------------
   Simple physics & collision
   ------------------------- */
function tileAt(screenIdx, tx, ty){
  const scr = worldScreens[screenIdx];
  if(!scr) return 0;
  if(ty < 0 || ty >= scr.map.length || tx < 0 || tx >= scr.map[0].length) return 0;
  return scr.map[ty][tx];
}
function worldToTile(x,y){ return {tx: Math.floor(x/TILE), ty: Math.floor(y/TILE)}; }

/* collision with map tiles (solid when tile>0) */
function isSolid(screenIdx, x,y,w,h){
  const left = Math.floor(x/TILE), right = Math.floor((x+w-1)/TILE);
  const top = Math.floor(y/TILE), bottom = Math.floor((y+h-1)/TILE);
  for(let ty=top; ty<=bottom; ty++){
    for(let tx=left; tx<=right; tx++){
      if(tileAt(screenIdx, tx, ty) > 0) return true;
    }
  }
  return false;
}

/* -------------------------
   Update & Render Loop
   ------------------------- */
let lastTime = performance.now();
let accum = 0;
let waveStartAt = performance.now();

function update(dt){
  if(paused) return;
  // input
  const left = keys['arrowleft'] || keys['a'];
  const right = keys['arrowright'] || keys['d'];
  const up = keys['arrowup'] || keys['w'];
  const down = keys['arrowdown'] || keys['s'];
  const punch = keys['z'];
  const kick = keys['x'];

  // horizontal movement
  const speed = 2.0 + Math.min(2, influence/120);
  if(left) { player.vx = -speed; player.dir = -1; player.state='walk'; }
  else if(right) { player.vx = speed; player.dir = 1; player.state='walk'; }
  else { player.vx = 0; if(player.onGround) player.state='idle'; }

  // jump
  if(up && player.onGround){ player.vy = -7.6; player.onGround=false; AUDIO.sfxBeep(720,0.06); }

  // gravity
  player.vy += 0.32; if(player.vy > 10) player.vy = 10;

  // movement + collision per axis
  // X
  let nx = player.x + player.vx;
  if(!isSolid(screenIndex, nx, player.y, player.w, player.h)) player.x = nx; else player.vx = 0;
  // Y
  let ny = player.y + player.vy;
  if(!isSolid(screenIndex, player.x, ny, player.w, player.h)) { player.y = ny; player.onGround=false; }
  else { 
    // landed
    if(player.vy > 0) player.onGround = true;
    player.vy = 0;
    // snap to tile
    player.y = Math.floor(player.y / TILE) * TILE;
  }

  // attack timers
  if(punch){ player.punchTimer = 6; AUDIO.sfxBeep(880,0.04); }
  if(kick){ player.kickTimer = 8; AUDIO.sfxBeep(720,0.04); }

  if(player.punchTimer>0) player.punchTimer--;
  if(player.kickTimer>0) player.kickTimer--;

  // NPC behavior: simple patrolling for thugs
  npcs.forEach(n=>{
    if(!n.alive) return;
    if(n.kind === 'thug'){
      n.timer += dt;
      // move between patrol bounds
      if(n.x < n.patrol[0]) n.dir = 1;
      if(n.x > n.patrol[1]) n.dir = -1;
      n.vx = n.dir * 0.6;
      // chase if close
      const dx = Math.abs(n.x - player.x);
      if(dx < 160){ // start chasing
        n.vx = (player.x < n.x ? -1.2 : 1.2);
      }
      n.x += n.vx;
      // simple collision with ground
      if(isSolid(screenIndex, n.x, n.y+1, n.w, n.h)){} else { n.y += 0.5; }
      // check collisions with player (damage)
      if(Math.abs(n.x - player.x) < 28 && Math.abs(n.y - player.y) < 24 && player.punchTimer==0 && player.kickTimer==0){
        // if player hits, damage npc
      }
    } else if(n.kind === 'mom'){
      // mom stands waiting, triggers dialog on interact
    }
  });

  // camera follow player and clamp to world width
  const scrW = worldScreens[screenIndex].map[0].length * TILE;
  cam.x = clamp(player.x - W/2 + player.w/2, 0, scrW - W);
  cam.y = 0;

  // world transitions: if player passes right edge, move to next screen
  const scrTiles = worldScreens[screenIndex].map[0].length;
  const scrWidthPx = scrTiles * TILE;
  if(player.x > scrWidthPx - player.w - 10){
    if(screenIndex < worldScreens.length -1){
      screenIndex++; player.x = 24; // enter next screen
      queueDialog("<b>District:</b> " + worldScreens[screenIndex].type);
      waveStartAt = performance.now();
    }
  }
  if(player.x < 0){
    if(screenIndex > 0){
      screenIndex--; player.x = worldScreens[screenIndex].map[0].length * TILE - player.w - 24;
      queueDialog("<b>District:</b> " + worldScreens[screenIndex].type);
      waveStartAt = performance.now();
    } else {
      // clamp to 0
      player.x = 0;
    }
  }

  // auto mission progression: after some time in screens, spawn little jobs / offers
  if(performance.now() - waveStartAt > 22000 && worldScreens[screenIndex].type === 'alley'){
    // spawn a "boss" that requests a sacrifice or offer
    // but only once: we can check a flag on screen
    if(!worldScreens[screenIndex].triggered){
      worldScreens[screenIndex].triggered = true;
      queueDialog([
        "A lieutenant approaches you with a question: \"You want to move up? Sacrifices must be made.\"",
        "Head to the apartment and speak with your mother. The choice you make will change the city around you."
      ]);
    }
  }

  // update influence/guilt gently over time (small drips)
  if(Math.random() < 0.004) { influence = Math.max(0, influence - 0.2); } // small decay
}

/* -------------------------
   Rendering
   ------------------------- */
function drawGrid(){
  const map = worldScreens[screenIndex].map;
  const cols = map[0].length, rows = map.length;
  const offsetX = -cam.x, offsetY = -cam.y;
  // sky gradient
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#081226'); g.addColorStop(1,'#071018'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  // parallax city silhouette
  ctx.fillStyle = 'rgba(6,8,12,0.9)';
  ctx.beginPath(); ctx.moveTo(0,H*0.7);
  ctx.lineTo(W*0.12, H*0.55); ctx.lineTo(W*0.33, H*0.66); ctx.lineTo(W*0.5, H*0.5); ctx.lineTo(W*0.7, H*0.62); ctx.lineTo(W, H*0.48);
  ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath(); ctx.fill();

  // tiles
  for(let ty=0; ty<rows; ty++){
    for(let tx=0; tx<cols; tx++){
      const t = map[ty][tx];
      if(t===0) continue;
      const x = tx * TILE + offsetX;
      const y = ty * TILE + offsetY;
      if(t===1){
        // platform tile
        ctx.fillStyle = '#1e1f24'; ctx.fillRect(x, y, TILE, TILE);
        // highlight
        ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fillRect(x+2, y+2, TILE-4, TILE-6);
      } else if(t===2){
        ctx.fillStyle = '#2b2b2f'; ctx.fillRect(x,y,TILE,TILE);
        ctx.fillStyle='rgba(255,255,255,0.03)'; ctx.fillRect(x+2,y+2,TILE-4,TILE-6);
      }
    }
  }
}

/* draw player, npcs */
function render(){
  clear();
  drawGrid();

  // draw npcs
  npcs.forEach(n=>{
    if(!n.alive) return;
    const sx = n.x - cam.x, sy = n.y - cam.y;
    // draw sprite
    if(n.kind === 'thug'){
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(SPRITES.thug, sx-14, sy-36, 56, 56);
    } else if(n.kind === 'mom'){
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(SPRITES.mom, sx-14, sy-36, 56, 56);
    } else {
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(SPRITES.thug, sx-14, sy-36, 56, 56);
    }
  });

  // player sprite
  ctx.save();
  const px = player.x - cam.x, py = player.y - cam.y;
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(SPRITES.player, px-14, py-36, 56, 56);
  // draw fists when punching
  if(player.punchTimer>0){
    ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fillRect(px + (player.dir*22), py-22, 8,8);
  }
  if(player.kickTimer>0){
    ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fillRect(px + (player.dir*20), py+4, 10,6);
  }
  ctx.restore();

  // HUD drawn via DOM, but we can draw mini debug
}

/* -------------------------
   UI update
   ------------------------- */
function updateStatsUI(){
  document.getElementById('txtInf').textContent = Math.floor(influence);
  document.getElementById('txtGuilt').textContent = Math.floor(guilt);
  document.getElementById('infBar').firstElementChild.style.width = Math.min(100, influence/3) + '%';
  document.getElementById('guiltBar').firstElementChild.style.width = Math.min(100, guilt) + '%';
}

/* -------------------------
   Game loop
   ------------------------- */
function gameLoop(timestamp){
  const dt = Math.min(32, timestamp - lastTime);
  lastTime = timestamp;
  update(dt);
  render();
  updateStatsUI();
  requestAnimationFrame(gameLoop);
}

/* -------------------------
   Start / story boot
   ------------------------- */
function boot(){
  // Start music when first interaction
  document.addEventListener('pointerdown', ()=> AUDIO.start(), {once:true});
  // initial story
  story.start();
  // queue intro dialog and instruction
  setTimeout(()=>{ queueDialog("Find your mother (walk to the apartment) and talk to her. Press Enter to advance dialog."); }, 400);
  requestAnimationFrame(gameLoop);
}

/* -------------------------
   Dialog advancement helper
   ------------------------- */
function advanceDialog(){ // handled above by Enter key and button
  // consumed via dialogNext click handler
}

/* -------------------------
   Endings / end game
   ------------------------- */
function checkEndingConditions(){
  // Basic hooks: if rank high and guilt high -> power; if rank high guilt low -> balance; low rank guilt low -> redemption
  if(rank >= 3){
    if(guilt > 70) endGame('Feast of Ashes', 'You rose to the top, but your name tastes of ash. Power devoured what you loved.');
    else endGame('Balance Achieved', 'You became a leader who kept some of himself. The city bends but you endure.');
  } else {
    if(performance.now() - waveStartAt > 360000) endGame('Quiet Redemption', 'You walked away. The streets kept their breath, and you kept your soul.');
  }
}
function endGame(title, text){
  document.getElementById('endTitle').textContent = title;
  document.getElementById('endText').textContent = text + ' (Influence: ' + Math.floor(influence) + ', Guilt: ' + Math.floor(guilt) + ')';
  document.getElementById('endScreen').style.display = 'flex';
  paused = true;
}

/* restart handler */
document.getElementById('restartBtn').addEventListener('click', ()=> location.reload());

/* wire up basic interactions: interact (down arrow) triggers dialog with nearby NPCs */
window.addEventListener('keydown', (e)=> {
  if(e.key === 'ArrowDown'){
    // check for NPC near player
    for(let n of npcs){
      if(Math.abs(n.x - player.x) < 48 && Math.abs(n.y - player.y) < 36){
        // trigger dialog node if mom
        if(n.kind === 'mom'){
          // trigger story node if not yet done
          story.mom_intro();
        } else {
          queueDialog("Thug: \"You hear me? Move along, kid.\"");
        }
        break;
      }
    }
  }
});

/* small helper to trigger early "boss" to demonstrate sacrifice progression */
setTimeout(()=> { /* nothing - example places to add scripted missions */ }, 2000);

/* Start the prototype */
boot();

/* Notes (developer):
  - To expand toward a full 60-min experience:
    * Add more worldScreens with distinct tiles and custom artwork.
    * Add scripted missions/quests per district (fetch, escort, heist mini-game).
    * Fill more NPCs with branching dialog trees stored as data.
    * Create persistent 'family' progression with ranks and unique abilities.
    * Add more sacrifice moments and consequences (remove/freeze NPCs, change map art).
    * Replace procedural sprites with hand-drawn/animated sprite sheets (base64-embed or external).
    * Add checkpoints, save system, and optimization for asset size.
  - Where to extend in code:
    * createWorld() — add more screens and custom layouts.
    * npcs[] — add more npc entries with dialogId references.
    * story.* — add new story nodes and branching logic.
    * performSacrifice() — add more nuanced mechanical consequences (permanent buffs/debuffs).
    * checkEndingConditions() — tune run length and ending conditions.
  - If you want, tell me "Add Act II: the docks heist mission" or "Embed a 2MB OGG for the main theme" and I'll implement that immediately into this same file.
*/

</script>
</body>
</html>
